N-body simulation code flow:

- SIMPLE DETERMINISTIC HAMILTONIAN vs MC?
- DO WE ASSUME WE'RE STARTING IN EQM?
    - yes: any observations we have of grav. bound bodies will be at some point far into their evolution, so nature will
      have equilibrated them for us already
    - actually just ignore this - just do a straightforward pair force calculation

SYSTEM OF 4n FIRST ORDER DIFFERENTIAL EQUATIONS, WITH 4n INITIAL CONDITIONS


Define class to deal with VECTORS
    - cross and dot products?
    - function: scalar distance between two vectors
    - function: vector sum
    - function: change of coordinates

Define class to hold info abt BODIES
    - position (as an x,y vector)
    - velocity (as an x,y vector)
    - mass (in some arbitrary units (solar masses? easier not to have to worry about massive numbers)
        - we'll treat these as point masses
    - function: calculate the force on this body from a single other body
    - function: calculate the force on this body from all other bodies using the previous function?

Define class to hold PHASE SPACE as a whole for an instant in time
    - should have time since t0 included, and all body classes
    - also some sort of different subclass for Fij matrix?
    - function: calculate the center of mass of this system
    - function: redefine all positions and velocities in terms of CoM
    - function: calculate the Fij matrix for the system at this instant



INITIALIZE

    PASS: initial phase space, initial masses (read in from file)

    RETURN: information correctly stored in the right classes and in the right frame

    - set up ICs x_ij, v_ij (phase space) for N + m unknown bodies, masses M_i for N + m bodies
    - i is body index, j is dimension index

    - zero the coordinate system to the initial center of mass and adjust coordinates?
        - need x,y positions and velocities defined in terms of this initial CoM
    - define boundaries?

    TESTS:
        - make sure information is stored in every phase space coordinate and mass (check for NaNs)
        - make sure none of the bodies are stacked on top of each other
        - make sure none of the bodies are wildly far away from all of the other ones


SINGLE ITERATION

    PASS: phase space of all bodies, time interval dt

    RETURN: phase space of all bodies after they have evolved for the duration of the time interval

    - FIRST, calculate the system of forces acting on each body i from all other bodies j
        - use constants of motion - center of mass moves with constant velocity (DO therefore want to be in CoM frame,
          bc it's inertial and so we can ignore this extra motion
        - gravitational potential has singularity at r_ij=0 - need to soften it somehow (usually w a small number epsilon
          in the denominator sqrt
        - system is chaotic - eqm is not stable but we see stability so some sort of eqm has been reached?
            - skip past this by again assuming the universe has put the bodies into eqm for us
      (just a matrix of Fij)

    - THEN, based on this force matrix, calculate where the bodies will be after t time
        - need integrator over the time interval dt passed
        - return new positions and velocities

    - use 2D cartesian coordinates (assume problem is confined to the plane)
    - this step is going to need to be optimized as much as possible
    - boundary conditions?

    TESTS:
        - check for NaNs
        - make sure none of the bodies are stacked on top of each other
        - make sure none of the masses have changed
        - make sure none of the coordinates are identical to what they were before
        - check that the CoM has not moved
        - calculate total energy before and after iterating, make sure it hasn't changed significantly
        - calculate angular momentum before and after iterating, make sure it hasn't changed significantly

WRAPPER TO ITERATE N_iter TIMES

    PASS: initial phase space, number of iterations, time interval dt

    RETURN: final phase space

    - just loop through the single iteration repeatedly
    - track all changes through time for future graphing, animation

    TESTS:
        - check for NaNs
        - make sure none of the bodies are stacked on top of each other
        - make sure none of the bodies are stacked on top of each other
        - make sure none of the masses have changed
        - make sure none of the coordinates are identical to what they were before
        - check that the CoM has not moved
        - calculate total energy before and after iterating, make sure it hasn't changed significantly
        - calculate angular momentum before and after iterating, make sure it hasn't changed significantly
        - make sure none of the bodies have run away to infinity

        then test that it actually works:
            - first test of complete simulation: kepler problem (single planet orbiting around very massive sun)

OBJECT-ORIENTED PROGRAMMING:
- define CLASSES - user-defined data structures (for body: mass, position, and velocity?)
- example:
    class body:
        # pass (this will just run the code without giving it an error- placeholder)

        # first have to INITIALIZE the class:
        def __init__(self, thing1, thing2):
            self.thing1 = thing1
            self.thing2 = thing2

        # a class ATTRIBUTE is something which is the same for all instances of the class

        attribute = thing3

        # can also define CHILD classes that step from the parent class, with further specifications